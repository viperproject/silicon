field next: Ref

field val: Ref

field int_val: Int


predicate outerseg(x: Ref, until: Ref) {
  x != until ==> (acc(x.val) && acc(x.next) && innerseg(x.val, null) && outerseg(x.next, until))
}

predicate innerseg(x: Ref, until: Ref) {
  x != until ==> (acc(x.int_val) && acc(x.next) && innerseg(x.next, until))
}

method sum(x: Ref)
  requires outerseg(x, null)
  ensures outerseg(x, null)
{
  var res: Int := 0
  var cur: Ref := x
  fold outerseg(cur, cur)
  while (cur != null)
  {
    unfold outerseg(cur, null)
    var icur: Ref
    var iinit: Ref
    iinit := cur.val
    icur := iinit
    fold innerseg(iinit, icur)
    while (icur!= null)
    {
      unfold innerseg(icur, null)
      res := res + icur.int_val

      var itmp: Ref := icur
      icur := icur.next
      fold innerseg(icur, icur)
      fold innerseg(itmp, icur)
      concatinnersegs(iinit, itmp, icur)
    }

    var tmp: Ref := cur
    cur := cur.next
    fold outerseg(cur, cur)
    fold outerseg(tmp, cur)
    concatoutersegs(x, tmp, cur)
  }
}


method sumf1(x: Ref)
  requires outerseg(x, null)
  ensures outerseg(x, null)
{
  var res: Int := 0
  var cur: Ref := x
  fold outerseg(cur, cur)
  while (cur != null)
  {
    unfold outerseg(cur, null)
    var icur: Ref
    var iinit: Ref
    iinit := cur.val
    icur := iinit
    fold innerseg(iinit, icur)
    while (icur!= null)
    {
      unfold innerseg(icur, null)
      res := res + icur.int_val

      var itmp: Ref := icur
      icur := icur.next
      //:: ExpectedOutput(fold.failed:insufficient.permission)
      fold innerseg(itmp, icur)
      concatinnersegs(iinit, itmp, icur)
    }

    var tmp: Ref := cur
    cur := cur.next
    fold outerseg(cur, cur)
    fold outerseg(tmp, cur)
    concatoutersegs(x, tmp, cur)
  }
}

method sumf2(x: Ref)
  requires outerseg(x, null)
  ensures outerseg(x, null)
{
  var res: Int := 0
  var cur: Ref := x
  while (cur != null)
  {
    unfold outerseg(cur, null)
    var icur: Ref
    var iinit: Ref
    iinit := cur.val
    icur := iinit
    fold innerseg(iinit, icur)
    while (icur!= null)
    {
      unfold innerseg(icur, null)
      res := res + icur.int_val

      var itmp: Ref := icur
      icur := icur.next
      fold innerseg(icur, icur)
      fold innerseg(itmp, icur)
      concatinnersegs(iinit, itmp, icur)
    }

    var tmp: Ref := cur
    cur := cur.next
    fold outerseg(cur, cur)
    fold outerseg(tmp, cur)
    //:: ExpectedOutput(call.precondition:insufficient.permission)
    concatoutersegs(x, tmp, cur)
  }
}

method sumf3(x: Ref)
  ensures outerseg(x, null)
{
  var res: Int := 0
  var cur: Ref := x
  fold outerseg(cur, cur)
  while (cur != null)
  {
    //:: ExpectedOutput(unfold.failed:insufficient.permission)
    unfold outerseg(cur, null)
    var icur: Ref
    var iinit: Ref
    iinit := cur.val
    icur := iinit
    fold innerseg(iinit, icur)
    while (icur!= null)
    {
      unfold innerseg(icur, null)
      res := res + icur.int_val

      var itmp: Ref := icur
      icur := icur.next
      fold innerseg(icur, icur)
      fold innerseg(itmp, icur)
      concatinnersegs(iinit, itmp, icur)
    }

    var tmp: Ref := cur
    cur := cur.next
    fold outerseg(cur, cur)
    fold outerseg(tmp, cur)
    concatoutersegs(x, tmp, cur)
  }
}


method sumPart(x: Ref)
  requires outerseg(x, null)
  ensures outerseg(x, null)
{
  var res: Int := 0
  var cur: Ref := x
  fold acc(outerseg(cur, cur), 1/2)
  while (cur != null)
  {
    unfold acc(outerseg(cur, null), 1/2)
    var icur: Ref
    var iinit: Ref
    iinit := cur.val
    icur := iinit
    fold acc(innerseg(iinit, icur), 1/4)
    while (icur!= null)
    {
      unfold acc(innerseg(icur, null), 1/4)
      res := res + icur.int_val

      var itmp: Ref := icur
      icur := icur.next
      fold acc(innerseg(icur, icur), 1/4)
      fold acc(innerseg(itmp, icur), 1/4)
      concatinnersegsp(iinit, itmp, icur, 1/4)
    }

    var tmp: Ref := cur
    cur := cur.next
    fold acc(outerseg(cur, cur), 1/2)
    fold acc(outerseg(tmp, cur), 1/2)
    concatoutersegsp(x, tmp, cur, 1/2)
  }
}

method sumPartf1(x: Ref)
  requires outerseg(x, null)
  ensures outerseg(x, null)
{
  var res: Int := 0
  var cur: Ref := x
  fold acc(outerseg(cur, cur), 1/2)
  while (cur != null)
  {
    unfold acc(outerseg(cur, null), 1/2)
    var icur: Ref
    var iinit: Ref
    iinit := cur.val
    icur := iinit
    fold acc(innerseg(iinit, icur), 1/4)
    while (icur!= null)
    {
      unfold acc(innerseg(icur, null), 1/4)
      res := res + icur.int_val
      //:: ExpectedOutput(assignment.failed:insufficient.permission)
      icur.int_val := icur.int_val + 1

      var itmp: Ref := icur
      icur := icur.next
      fold acc(innerseg(icur, icur), 1/4)
      fold acc(innerseg(itmp, icur), 1/4)
      concatinnersegsp(iinit, itmp, icur, 1/4)
    }

    var tmp: Ref := cur
    cur := cur.next
    fold acc(outerseg(cur, cur), 1/2)
    fold acc(outerseg(tmp, cur), 1/2)
    concatoutersegsp(x, tmp, cur, 1/2)
  }
}

method sumPartf2(x: Ref)
  requires outerseg(x, null)
  ensures outerseg(x, null)
{
  var res: Int := 0
  var cur: Ref := x
  fold acc(outerseg(cur, cur), 1/2)
  while (cur != null)
  {
    unfold acc(outerseg(cur, null), 1/2)
    var icur: Ref
    var iinit: Ref
    iinit := cur.val
    icur := iinit
    fold acc(innerseg(iinit, icur), 1/4)
    while (icur!= null)
    {
      unfold acc(innerseg(icur, null), 1/4)
      res := res + icur.int_val

      var itmp: Ref := icur
      icur := icur.next
      fold acc(innerseg(icur, icur), 1/4)
      fold acc(innerseg(itmp, icur), 1/4)
      //:: ExpectedOutput(call.precondition:insufficient.permission)
      concatinnersegsp(iinit, itmp, icur, 1/2)
    }

    var tmp: Ref := cur
    cur := cur.next
    fold acc(outerseg(cur, cur), 1/2)
    fold acc(outerseg(tmp, cur), 1/2)
    concatoutersegsp(x, tmp, cur, 1/2)
  }
}

method concatoutersegs(x: Ref, y: Ref, z: Ref)
  requires outerseg(x, y) && outerseg(y, z)
  ensures outerseg(x, z)

method concatinnersegs(x: Ref, y: Ref, z: Ref)
  requires innerseg(x, y) && innerseg(y, z)
  ensures innerseg(x, z)

method concatinnersegsp(x: Ref, y: Ref, z: Ref, p: Perm)
  requires p > none
  requires acc(innerseg(x, y), p) && acc(innerseg(y, z), p)
  ensures acc(innerseg(x, z), p)

method concatoutersegsp(x: Ref, y: Ref, z: Ref, p: Perm)
  requires p > none
  requires acc(outerseg(x, y), p) && acc(outerseg(y, z), p)
  ensures acc(outerseg(x, z), p)