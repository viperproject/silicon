import "./sl.vpr"


method free(x: Ref)
requires acc(x.next) && acc(x.data)
ensures true
{
    exhale acc(x.next) && acc(x.data)
}

method havoc() returns (b: Bool)


method filter(x: Ref) //returns (res: Ref)
//requires list(x)
//ensures list(x)
{
    var curr: Ref := x
    var nondet: Bool

    /*
    while(nondet && curr != null)
    //invariant list(curr)
    {
        var prev: Ref := curr
        //unfold list(curr)
        curr := curr.next
        free(prev)
        nondet := havoc()
    }*/

    //res := curr

    //package list(curr) --* list(res)
    while(curr != null)
    //invariant list(curr) --* list(res)
    //invariant list(curr)
    {
        var old_curr: Ref := curr
        
        //unfold list(curr)
        nondet := havoc()

        if(nondet && curr.next != null) {
            //unfold list(curr.next)
            var n: Ref := curr.next
            curr.next := n.next
            exhale acc(n.next) && acc(n.data)
            //fold list(curr)
        
        } else {
            curr := curr.next
            //package list(curr) --* list(res) {
            //    fold list(old_curr)
            //    apply list(old_curr) --* list(res)
            //}
        }  
    }
    //apply list(curr) --* list(res)
}

/*
method filter1(x: Ref) returns (res: Ref)
//requires list(x)
//ensures list(x)
{
    if(x == null) {
        res := null
    } else {
        //unfold list(x)
        var prev: Ref := x
        var curr: Ref := x.next

        //package list(prev) --* list(x)

        while(curr != null)
        //invariant list(prev) --* list(x)
        //invariant acc(prev.next)
        //invariant acc(prev.data)
        invariant prev.next == curr
        //invariant list(curr)
        {
            var old_curr: Ref := curr
            var old_prev: Ref := prev
            
            //unfold list(curr)
            curr := curr.next

            var nondet: Bool
            if(nondet) {
                prev.next := curr;
                free(old_curr)
            } else {
                prev := old_curr
            }

            if(!nondet){
                //package list(prev) --* list(x) {
                //    //fold list(old_prev)
                //    //apply list(old_prev) --* list(x)
                //}
            }
         }
         //fold list(curr)
         //fold list(prev)
         //apply list(prev) --* list(x)
    }
}*/
