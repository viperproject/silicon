import "sl.vpr"

method split(x: Ref) returns (greq: Ref, pivot: Ref, less: Ref)
//requires list(x)
requires x != null
//ensures list(greq) && list(less)
//ensures acc(pivot.data) && acc(pivot.next)
{
    //unfold list(x)
    pivot := x
    greq := x.next
    pivot.next := null
    
    less := null
    //fold list(less)

    //unfold list(greq)

    var prev: Ref := greq
    var curr: Ref := greq.next
    var pivot_val: Int := pivot.data

    if(greq != null && greq.next != null){
        
    
        //package list(prev) --* list(greq)

        var done: Bool := false
        while(curr != null && !done)
        //invariant list(curr)
        //invariant acc(prev.data) 
        invariant acc(prev.next)
        invar12iant prev.next == curr
        //invariant list(prev) --* list(greq)
        {
            var prev_old: Ref := prev
            //unfold list(curr)
            done := curr.data < pivot_val

            if(!done){
                prev := curr
                curr := curr.next
            }
            //package list(prev) --* list(greq){
                //fold list(prev_old)
                //apply list(prev_old) --* list(greq)
            //}
        }
        var curr_less: Ref := curr
        if(curr != null){
            
            //unfold list(curr)
            less := curr
            //package list(curr_less) --* list(less)

            
            
            curr := curr.next
            prev.next := curr
            var greq_mid: Ref := prev

            while(curr != null)
            invariant list(curr)
            invariant acc(prev.data)
            invariant acc(prev.next)
            invariant prev.next == curr
            invariant list(prev) --* list(greq_mid)
            invariant acc(curr_less.data) && acc(curr_less.next)
            //invariant list(curr_less) --* list(less)
            {
                //unfold list(curr)
                var cond: Bool := curr.data < pivot_val
                if(cond){
                    var prev_less: Ref := curr_less
                    curr_less.next := curr
                    curr_less := curr
                    package list(curr_less) --* list(less){
                        fold list(prev_less)
                        apply list(prev_less) --* list(less)
                    }

                    curr := curr.next
                    prev.next := curr
                } else {
                    var prev_old: Ref := prev
                    prev := curr
                    curr := curr.next
                    //package list(prev) --* list(greq){
                    //    fold list(prev_old)
                    //    apply list(prev_old) --* list(greq)
                    //}
                }
            }
            curr_less.next := null
            //fold list(curr_less.next)
            //fold list(curr_less)
            //apply list(curr_less) --* list(less)
        }

            //fold list(prev)
            //apply list(prev) --* list(greq)
    }
}



method concat(x: Ref, y: Ref) returns (res: Ref)
requires list(x) && list(y)
ensures list(res)

/*
method quicksort(x: Ref) returns (res: Ref)
requires list(x)
ensures list(res)
{
    if(x == null){
        res := x
    } else {
        var g: Ref
        var p: Ref
        var l: Ref
        g, p, l  := split(x)
        g := quicksort(g)
        l := quicksort(l)
        p.next := l
        fold list(p)
        res := concat(g, p)
    }
}*/