import "sl.vpr"

method free(x: Ref)
requires acc(x.next) && acc(x.data)

method difference(lst1: Ref, lst2: Ref) returns (res: Ref)
//requires list(lst1) && list(lst2)
//ensures list(res) && list(lst2)
{ 
    res := lst1
    if(lst1 != null && lst2 != null){
    
        var curr_2: Ref := lst2
        //package list(curr_2) --* list(lst2)
        var done: Bool := false
        while(res != null && curr_2 != null && !done)
            //invariant list(curr_2)
            //invariant list(curr_2) --* list(lst2)
            //invariant list(res)
        {
            var prev_2: Ref := curr_2
            //unfold list(curr_2)
            //unfold list(res)

            done := res.data == curr_2.data

            if(!done){
                var prev_res: Ref := res
                res := res.next
                curr_2 := curr_2.next
                free(prev_res)

                //package list(curr_2) --* list(lst2){
                    //fold list(prev_2)
                    //apply list(prev_2) --* list(lst2)
                //}
            }
        }
        
        if(res != null && curr_2 != null){
            
            var prev_res: Ref := res
            //package list(prev_res) --* list(res)
            //unfold list(res)
            var curr_res: Ref := res.next
            
            var mid_2: Ref := curr_2

            while(curr_res != null && curr_2 != null)
            //invariant list(curr_2) 
            //invariant list(curr_2) --* list(lst2)
            //invariant list(curr_res)
            //invariant acc(prev_res.data)
            invariant acc(prev_res.next)
            invariant prev_res.next == curr_res
            //invariant list(prev_res) --* list(res)
            {
                var prev_22: Ref := curr_2
                var prev_res_old: Ref := prev_res
                
                //unfold list(curr_2)
                //unfold list(curr_res)

                var cond1: Bool := curr_res.data < curr_2.data
                var cond2: Bool := curr_res.data > curr_2.data
                if(curr_res.data < curr_2.data){
                    curr_res := curr_res.next
                    prev_res := prev_res.next
                    curr_2 := curr_2.next
                    //package list(prev_res) --* list(res){
                    //    fold list(prev_res_old)
                    //    apply list(prev_res_old) --* list(res)
                    //}
                    package list(curr_2) --* list(mid_2){
                        fold list(prev_22)
                        apply list(prev_22) --* list(mid_2)
                    }
                } elseif(curr_res.data > curr_2.data){
                    curr_2 := curr_2.next
                    package list(curr_2) --* list(mid_2){
                        fold list(prev_22)
                        apply list(prev_22) --* list(mid_2)
                    }
                    fold list(curr_res)
                } else {
                    prev_res.next := curr_res.next
                    free(curr_res)
                    curr_res := prev_res.next
                    fold list(curr_2)
                }    
            }
            //fold list(prev_res)
            //apply list(prev_res) --* list(res)
        }
        //apply list(curr_2) --* list(lst2)
    }
}

/*
method difference1(lst1: Ref, lst2: Ref) returns (res: Ref)
//requires list(lst1) && list(lst2)
//ensures list(res)
{
    if(lst1 == null){
        res := lst2
    } elseif(lst2 == null) {
        res := lst1
    } else {
        var x: Ref := lst1
        var y: Ref := lst2
        while(x != null && y != null && unfolding list(x) in unfolding list(y) in x.data == y.data)
            //invariant list(x) && list(y)
        {
            //unfold list(x)
            //unfold list(y)
            x := x.next
            y := y.next
        }

        if(x == null){
            res := y
        } elseif(y == null){
            res := x
        } else {
            //unfold list(x)
            //unfold list(y)
            if(x.data < y.data){
                res := x
                x := x.next
                res.next := null
                //fold list(y)
            } else {
                res := y
                y := y.next
                res.next := null
                //fold list(x)
            }
            var res_curr: Ref := res
            //package list(res_curr) --* list(res)
            while(x != null && y != null)
            //invariant list(x) && list(y)
            //invariant list(res_curr) --* list(res)
            //invariant acc(res_curr.data) && acc(res_curr.next)
            {
                //unfold list(x)
                //unfold list(y)
                if(x.data == y.data){
                    x := x.next
                    y := y.next
                } else {
                    if(x.data < y.data){
                        res_curr.next := x
                        x := x.next
                        //fold list(y)
                    } else {
                        res_curr.next := y
                        y := y.next
                        //fold list(x)
                    }

                    var res_prev: Ref := res_curr
                    res_curr := res_curr.next
                    //package list(res_curr) --* list(res){
                        //fold list(res_prev)
                        //apply list(res_prev) --* list(res)
                    }
                }
            }
            
            if(x == null){
                res_curr.next := y
            } else {
                res_curr.next := x
            }
            //fold list(res_curr)
            //apply list(res_curr) --* list(res)
        }
    }
}*/