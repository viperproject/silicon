import "./sl.vpr"

function length(x: Ref): Int
requires list(x)
{
    x == null ? 0 : unfolding list(x) in 1 + length(x.next)
}


method merge(a: Ref, b: Ref) returns (res: Ref)
requires list(a) && list(b)
ensures list(res)
{
    res := null
    if(a == null){
        res := b
    } else { 
        if(b == null) {
            res := a
        } else {
            var aIt: Ref := a
            var bIt: Ref := b
            if (unfolding list(a) in a.data <= unfolding list(b) in b.data) {
                res := a
                unfold list(a)
                aIt := a.next
                bIt := b
            } else {
                res := b
                unfold list(b)
                aIt := a
                bIt := b.next
            }

            var last: Ref := res
            package list(last) --* list(res)

            while (aIt != null || bIt != null)
            invariant list(aIt) && list(bIt)
            invariant acc(last.next) && acc(last.data)
            invariant last.next == aIt || last.next == bIt
            invariant list(last) --* list(res)
            {
                var old_last: Ref := last
                
                unfold list(aIt)
                unfold list(bIt)
                if(aIt == null || bIt != null && aIt.data > bIt.data){
                    last.next := bIt
                    last := bIt
                    bIt := bIt.next
                    fold list(aIt)
                } else {
                    last.next := aIt
                    last := aIt
                    aIt := aIt.next
                    fold list(bIt)
                }
                package list(last) --* list(res){
                    fold list(old_last)
                    apply list(old_last) --* list(res)
                }
            }
            fold list(last)
            apply list(last) --* list(res)
        }
    }
}

method split(x: Ref) returns (y: Ref, z: Ref)
requires list(x)
ensures list(y) && list(z)
{
    var mid: Int
    mid := length(x) / 2

    var i: Int := 0

    var curr: Ref := x

    package list(curr) --* list(x)

    while (i < mid && curr != null)
    invariant list(curr) --* list(x)
    invariant list(curr)
    {

        var prev: Ref := curr
        unfold list(curr)
        curr := curr.next

        i := i + 1

        package list(curr) --* list(x){
            fold list(prev)
            apply list(prev) --* list(x)
        }
    }

    if(curr != null){
        var tmp: Ref := curr
        unfold list(curr)
        curr := curr.next
        tmp.next := null
        fold list(tmp.next)
        fold list(tmp)
        apply list(tmp) --* list(x)

        y := x
        z := curr
    } else {
        y := x
        apply list(curr) --* list(x)
        z := null
        fold list(z)
    }
}

method merge_sort(x: Ref) returns (res: Ref)
requires list(x)
ensures list(res)
{
    var x1: Ref, x2: Ref
    var res1: Ref , res2: Ref
    x1, x2 := split(x)
    res1 := merge_sort(x1)
    res2 := merge_sort(x2)
    res := merge(res1, res2)

}