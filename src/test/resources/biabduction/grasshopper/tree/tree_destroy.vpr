import "./tree.vpr"

method destroy(root: Ref)
//requires tree(root)
{
    if(root != null){
        var remaining: Ref := new(elem, tNext)
        remaining.tNext := null
        remaining.elem := root
        //fold tList(remaining.tNext)
        //fold tList(remaining)

        while(remaining != null)
        //invariant tList(remaining)
        {
            //unfold tList(remaining)
            var current: Ref := remaining.elem
            if(current != null){

                //unfold tree(current)

                var lNode: Ref := new(elem, tNext)
                var rNode: Ref := new(elem, tNext)
                lNode.elem := current.left
                rNode.elem := current.right

                rNode.tNext := remaining.tNext
                lNode.tNext := rNode
                remaining.tNext := lNode

                freeT(current)

                //fold tList(rNode)
                //fold tList(lNode)
            }
            var remaining_root: Ref := remaining
            remaining := remaining.tNext
            freeL(remaining_root)
        }
    }    
}

method freeT(root: Ref)
requires acc(root.left) && acc(root.right) && acc(root.val)

method freeL(node: Ref)
requires acc(node.elem) && acc(node.tNext)
