import "./tree.vpr"

method merge(leftT: Ref, rightT: Ref) returns (res: Ref)
requires tree(leftT) && tree(rightT)
ensures tree(res)

method free(root: Ref)
requires acc(root.left) && acc(root.right) && acc(root.val)

method remove(root: Ref, value: Int) returns (res: Ref)
  //requires tree(root)
  //ensures tree(res)
{
    
    var found: Bool := false
    if(root == null){
        res := root
    } else {

        var curr: Ref := root
           
        unfold tree(root)
        if(root.val == value){
            res := merge(root.left, root.right)
            free(root)
        } else {
            
            //fold tree(curr)
            //package tree(curr) --* tree(root) 

            while(!found)
            //invariant tree(curr) --* tree(root)
            invariant tree(curr)
            {
                
                var prev: Ref := curr
                //unfold tree(curr)

                var cond: Bool := curr.val < value
                if(cond){
                    curr := curr.right
                    
                    if(curr != null){
                        //unfold tree(curr)
                        var cond1: Bool := curr.val == value
                        if(cond1){
                            found := true
                            prev.right := merge(curr.left, curr.right)
                            free(curr)
                            curr := prev.right
                        }
                    } else {
                        curr := prev
                        found := true
                    } 
                } else {
                    curr := curr.left
                    if(curr != null){
                        //unfold tree(curr)
                        var cond2: Bool := curr.val == value
                        if(cond2){
                            found := true
                            prev.left := merge(curr.left, curr.right)
                            free(curr)
                            curr := prev.left
                        }
                    } else {
                        curr := prev
                        found := true
                    } 
                }

                //if(!found){
                //    fold tree(curr)
                //} 
                //package tree(curr) --* tree(root){
                //        fold tree(prev)
                //        apply tree(prev) --* tree(root)
                //}
            }
            //apply tree(curr) --* tree(root)
            res := root
        }
    }
}


                                    
                
                
                
                /*
                //unfold tree(curr.left)
                //unfold tree(curr.right)

                // We found it to the left
                var lefCond: Bool := curr.left != null && curr.left.val == value
                if(lefCond){
                    found := true
                    var left_old: Ref := curr.left
                    var left_new: Ref
                    left_new := merge(curr.left.left, curr.left.right)
                    curr.left := left_new
                    free(left_old)
                    //fold tree(curr.right)

                } else {
                    
                    // We found it to the right
                    var rightCond: Bool := curr.right != null && curr.right.val == value
                    if(rightCond){
                        found := true
                        var right_old: Ref := curr.right
                        var right_new: Ref
                        right_new := merge(curr.right.left, curr.right.right)
                        curr.right := right_new
                        free(right_old)
                        //fold tree(curr.left)
                    } else {

                        // We progress along the tree
                        var curr_old: Ref := curr
                        var rCond: Bool := curr.val < value
                        if(rCond){
                            var rCond1: Bool := curr.right == null
                            if(rCond1){
                                found := true
                                //fold tree(curr.left)
                                //fold tree(curr.right)
                            } else {
                                //fold tree(curr.left)
                                curr := curr.right
                                //package tree(curr) --* tree(root){
                                    //fold tree(curr_old)
                                    //apply tree(curr_old) --* tree(root)
                                //}
                            }
                        } else {
                            var lCond: Bool := curr.left == null
                            if(lCond){
                                found := true
                                //fold tree(curr.left)
                                //fold tree(curr.right)
                            } else {
                                //fold tree(curr.right)
                                curr := curr.left
                                //package tree(curr) --* tree(root){
                                    //fold tree(curr_old)
                                    //apply tree(curr_old) --* tree(root)
                                //}
                            }
                        }
                    }
                }*/