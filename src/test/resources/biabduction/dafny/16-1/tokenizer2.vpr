import "tokenizer.vpr"

method Read(this: Ref) returns (cat: Category, p: Int, token: Seq[Int]) 
    //requires Tokenizer(this)
    //ensures Tokenizer(this)
{
    // skip whitespace
    while (getN(this) != |getSource(this)| && Is(getSource(this)[getN(this)], Whitespace()))
        //invariant Tokenizer(this)
    {
        //unfold Tokenizer(this)
        this.n := this.n + 1
        //fold Tokenizer(this)
    }
    p := getN(this)
    // determine syntactic category
    var return: Bool := false
    if (getN(this) == |getSource(this)|)
    {
        cat := End()
        token := Seq()
        return := true
    }
    elseif (Is(getSource(this)[getN(this)], Identifier()))
    {
        cat := Identifier()
    }
    elseif (Is(getSource(this)[getN(this)], Number()))
    {
        cat := Number()
    }
    elseif (Is(getSource(this)[getN(this)], Operator()))
    {
        cat := Operator()
    }
    else
    {
        cat := Error()
        token := Seq()
        return := true
    }
    // read token
    if (!return)
    {
        var start: Int := getN(this)
        //unfold Tokenizer(this)
        this.n := this.n + 1
        //fold Tokenizer(this)
        while (getN(this) != |getSource(this)| && Is(getSource(this)[getN(this)], cat))
            //invariant Tokenizer(this)
        {
            //unfold Tokenizer(this)
            this.n := this.n + 1
            //fold Tokenizer(this)
        }
        token := getSource(this)[start..getN(this)]
    }    
}
        



    