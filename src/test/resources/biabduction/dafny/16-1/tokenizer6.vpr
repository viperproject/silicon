import "tokenizer.vpr"

field suffix: Seq[Int]
field m: Int
field j: Int

function getJ(this: Ref): Int
    requires Tokenizer(this)
    ensures 0 <= result <= unfolding Tokenizer(this) in |this.suffix|
{
    unfolding Tokenizer(this) in this.j
}


predicate TokenizerWithPruning(this: Ref)
{
    acc(this.source) && acc(this.suffix) && acc(this.m) && acc(this.j) &&
    acc(this.n) && 0 <= this.n <= |this.source| &&
    this.suffix == this.source[this.m..] && this.m + this.j == this.n &&
    0 <= this.m <= this.n && 0 <= this.j <= |this.suffix| &&
    forall i: Int :: 0 <= i < |this.source| ==> 0 <= this.source[i] <= 127
}

method ReadWithPruning(this: Ref) returns (cat: Category, p: Int, token: Seq[Int])
    //requires TokenizerWithPruning(this)
    //ensures 0 <= p
    //ensures TokenizerWithPruning(this)
    //ensures unfolding TokenizerWithPruning(this) in this.source == old(unfolding TokenizerWithPruning(this) in this.source)
    //ensures unfolding TokenizerWithPruning(this) in this.m == old(unfolding TokenizerWithPruning(this) in this.m) 
    //ensures !cat.isWhitespace
    //ensures unfolding TokenizerWithPruning(this) in old(unfolding TokenizerWithPruning(this) in this.n) <= p <= this.n <= |this.source|
    //ensures unfolding TokenizerWithPruning(this) in cat.isEnd <==> p == |this.source|
    //ensures unfolding TokenizerWithPruning(this) in cat.isEnd || cat.isError <==> p == this.n
    //ensures unfolding TokenizerWithPruning(this) in forall i: Int :: old(unfolding TokenizerWithPruning(this) in this.n) <= i < p ==> Is(this.source[i], Whitespace())
    //ensures unfolding TokenizerWithPruning(this) in forall i: Int :: p <= i < this.n ==> Is(this.source[i], cat)
    //ensures unfolding TokenizerWithPruning(this) in p < this.n ==> this.n == |this.source| || !Is(this.source[this.n], cat)
    //ensures unfolding TokenizerWithPruning(this) in token == this.suffix[p-this.m..this.j]
{
    //unfold TokenizerWithPruning(this)
    assert 0 <= getJ(this) <= |this.suffix|
    //fold TokenizerWithPruning(this)
    // skip whitespace
    while (unfolding TokenizerWithPruning(this) in this.j != |this.suffix| && Is(this.suffix[this.j], Whitespace()))
        //invariant TokenizerWithPruning(this)
        //invariant unfolding TokenizerWithPruning(this) in this.m == old(unfolding TokenizerWithPruning(this) in this.m) 
        //invariant unfolding TokenizerWithPruning(this) in this.source == old(unfolding TokenizerWithPruning(this) in this.source)
        //invariant unfolding TokenizerWithPruning(this) in old(unfolding TokenizerWithPruning(this) in this.n) <= this.n <= |this.source|
        //invariant unfolding TokenizerWithPruning(this) in forall i: Int :: old(unfolding TokenizerWithPruning(this) in this.n) <= i < this.n ==> Is(this.source[i], Whitespace())
    {
        //unfold TokenizerWithPruning(this)
        this.n := this.n + 1
        this.j := this.j + 1
        //fold TokenizerWithPruning(this)
    }
    //unfold TokenizerWithPruning(this)
    p := this.n
    //fold TokenizerWithPruning(this)
    // determine syntactic category
    var return: Bool := false
    if (unfolding TokenizerWithPruning(this) in this.n == |this.source|)
    {
        cat := End()
        token := Seq()
        return := true
    }
    elseif (unfolding TokenizerWithPruning(this) in Is(this.source[this.n], Identifier()))
    {
        cat := Identifier()
    }
    elseif (unfolding TokenizerWithPruning(this) in Is(this.source[this.n], Number()))
    {
        cat := Number()
    }
    elseif (unfolding TokenizerWithPruning(this) in Is(this.source[this.n], Operator()))
    {
        cat := Operator()
    }
    else
    {
        cat := Error()
        token := Seq()
        return := true
        assert unfolding TokenizerWithPruning(this) in p - this.m == this.j
    }
    // read token
    if (!return)
    {
        //unfold TokenizerWithPruning(this)
        var start: Int := this.j
        this.n := this.n + 1
        this.j := this.j + 1
        //fold TokenizerWithPruning(this)
        while (unfolding TokenizerWithPruning(this) in this.n != |this.source| && Is(this.source[this.n], cat))
            //invariant TokenizerWithPruning(this)
            //invariant unfolding TokenizerWithPruning(this) in this.m == old(unfolding TokenizerWithPruning(this) in this.m) 
            //invariant unfolding TokenizerWithPruning(this) in this.source == old(unfolding TokenizerWithPruning(this) in this.source)
            //invariant unfolding TokenizerWithPruning(this) in p <= this.n <= |this.source|
            //invariant unfolding TokenizerWithPruning(this) in forall i: Int :: p <= i < this.n ==> Is(this.source[i], cat)
        {
            //unfold TokenizerWithPruning(this)
            this.n := this.n + 1
            this.j := this.j + 1
            //fold TokenizerWithPruning(this)
        }
        //unfold TokenizerWithPruning(this)
        token := this.suffix[start..this.j]
        //fold TokenizerWithPruning(this)
    }    
}