import "tokenizer.vpr"

field suffix: Seq[Int]
field m: Int
field j: Int

function getJ(this: Ref): Int
    requires TokenizerWithPruning(this)
    ensures 0 <= result <= unfolding TokenizerWithPruning(this) in |this.suffix|
{
    unfolding TokenizerWithPruning(this) in this.j
}

function getSuffix(this: Ref): Seq[Int]
    requires TokenizerWithPruning(this)
    //ensures 0 <= result <= unfolding TokenizerWithPruning(this) in |this.suffix|
{
    unfolding TokenizerWithPruning(this) in this.suffix
}

predicate TokenizerWithPruning(this: Ref)
{
    acc(this.source) && acc(this.suffix) && acc(this.m) && acc(this.j) &&
    acc(this.n) && 0 <= this.n <= |this.source| &&
    this.suffix == this.source[this.m..] && this.m + this.j == this.n &&
    0 <= this.m <= this.n && 0 <= this.j <= |this.suffix| &&
    forall i: Int :: 0 <= i < |this.source| ==> 0 <= this.source[i] <= 127
}

method ReadWithPruning(this: Ref) returns (cat: Category, p: Int, token: Seq[Int])
    //requires TokenizerWithPruning(this)
    //ensures TokenizerWithPruning(this)
{
    //unfold TokenizerWithPruning(this)
    assert 0 <= getJ(this) <= |getSuffix(this)|
    //fold TokenizerWithPruning(this)
    // skip whitespace
    while (unfolding TokenizerWithPruning(this) in this.j != |this.suffix| && Is(this.suffix[this.j], Whitespace()))
        //invariant TokenizerWithPruning(this)
    {
        //unfold TokenizerWithPruning(this)
        this.n := this.n + 1
        this.j := this.j + 1
        //fold TokenizerWithPruning(this)
    }
    //unfold TokenizerWithPruning(this)
    p := this.n
    //fold TokenizerWithPruning(this)
    // determine syntactic category
    var return: Bool := false
    if (unfolding TokenizerWithPruning(this) in this.n == |this.source|)
    {
        cat := End()
        token := Seq()
        return := true
    }
    elseif (unfolding TokenizerWithPruning(this) in Is(this.source[this.n], Identifier()))
    {
        cat := Identifier()
    }
    elseif (unfolding TokenizerWithPruning(this) in Is(this.source[this.n], Number()))
    {
        cat := Number()
    }
    elseif (unfolding TokenizerWithPruning(this) in Is(this.source[this.n], Operator()))
    {
        cat := Operator()
    }
    else
    {
        cat := Error()
        token := Seq()
        return := true
        //assert unfolding TokenizerWithPruning(this) in p - this.m == this.j
    }
    // read token
    if (!return)
    {
        unfold TokenizerWithPruning(this)
        var start: Int := this.j
        this.n := this.n + 1
        this.j := this.j + 1
        //fold TokenizerWithPruning(this)
        while (unfolding TokenizerWithPruning(this) in this.n != |this.source| && Is(this.source[this.n], cat))
            //invariant TokenizerWithPruning(this)
        {
            //unfold TokenizerWithPruning(this)
            this.n := this.n + 1
            this.j := this.j + 1
            //fold TokenizerWithPruning(this)
        }
        //unfold TokenizerWithPruning(this)
        token := this.suffix[start..this.j]
        fold TokenizerWithPruning(this)
    }    
}