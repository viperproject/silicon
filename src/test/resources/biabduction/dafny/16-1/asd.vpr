import "tokenizer.vpr"

function IsStart(ch: Int, cat: Category): Bool
    requires !cat.isEnd
    requires 0 <= ch <= 127
{
    Is(ch, Identifier())
}

function IsFollow(ch: Int, cat: Category): Bool
    requires !cat.isEnd
    requires 0 <= ch <= 127
{
    Is(ch, Identifier()) || Is(ch, Number())
}

method ReadModifedIdentifier(this: Ref)
  returns (cat: Category, p: Int, token: Seq[Int])
  requires acc(Tokenizer(this), write)
  ensures acc(Tokenizer(this), write)
{
  {
    var oldSource: Seq[Int]
    var oldN: Int
    var return: Bool
    oldSource := getSource(this)
    oldN := getN(this)
    while (getN(this) != |getSource(this)| &&
    Is(getSource(this)[getN(this)], Whitespace()))
      invariant acc(Tokenizer(this), write)
      invariant getSource(this) == oldSource
      invariant oldN <= getN(this) && getN(this) <= |getSource(this)|
      invariant (forall i: Int ::
          { Is(getSource(this)[i], Whitespace()) }
          oldN <= i && i < getN(this) ==>
          Is(getSource(this)[i], Whitespace())) 
    {
      unfold acc(Tokenizer(this), write)
      this.n := this.n + 1
      fold acc(Tokenizer(this), write)
    }
    p := getN(this)
    return := false
    if (getN(this) == |getSource(this)|) {
      cat := End()
      token := Seq[Int]()
      return := true
    } elseif (Is(getSource(this)[getN(this)], Identifier())) {
      cat := Identifier()
    } elseif (Is(getSource(this)[getN(this)], Number())) {
      cat := Number()
    } elseif (Is(getSource(this)[getN(this)], Operator())) {
      cat := Operator()
    } else {
      cat := Error()
      token := Seq[Int]()
      return := true
    }
    if (!return) {
      var start: Int
      start := getN(this)
      if (cat.isOperator &&
      !IsStart(getSource(this)[getN(this)], cat)) {
        return := true
      } else {
        unfold acc(Tokenizer(this), write)
        this.n := this.n + 1
        fold acc(Tokenizer(this), write)
        while (getN(this) != |getSource(this)| &&
        (Is(getSource(this)[getN(this)], cat) && !return))
          invariant acc(Tokenizer(this), write)
          invariant getSource(this) == oldSource
          invariant p <= getN(this) && getN(this) <= |getSource(this)|
          invariant (forall i: Int ::
              { Is(getSource(this)[i], cat) }
              p <= i && i < getN(this) ==> Is(getSource(this)[i], cat)) 
        {
          if (cat.isOperator &&
          !IsFollow(getSource(this)[getN(this)], cat)) {
            return := true
          } else {
            unfold acc(Tokenizer(this), write)
            this.n := this.n + 1}
            fold acc(Tokenizer(this), write)
        }
      }
      if (return) {
        cat := Error()
        token := Seq[Int]()
        if (return) {
          unfold acc(Tokenizer(this), write)
        }
        this.n := p
        fold acc(Tokenizer(this), write)
      } else {
        token := getSource(this)[start..getN(this)]}
    }
  }
}