field next : Ref
field val : Int

predicate list(start : Ref)
{
  acc(start.val) && acc(start.next) &&
    (start.next != null && list(start.next))
}


method basicApply()
{
    var x: Int
    var y: Int
    inhale x > 0
    inhale x > 0 --* y > 0
    apply x > 0 --* y > 0
    assert y > 0
}


method basicPackage(l: Ref) 
  requires list(l) 
  ensures list(l)
  {
    unfold list(l)
    var tmp : Ref
    //@assumptionType("Explicit")
    tmp := l.next

    //@assumptionType("Implicit")
    package list(tmp) --* list(l)
    {
      fold list(l)
    }

    //@assumptionType("Implicit")
    apply list(tmp) --* list(l)
}

method appendit_wand(l1 : Ref, l2: Ref)
  requires list(l1) && list(l2) && l2 != null
  ensures list(l1) // && elems(l1) == old(elems(l1) ++ elems(l2))
  {
    unfold list(l1)
    assume l1.val >= 0
    if(l1.next == null) { // easy case
      l1.next := l2; fold list(l1)
    } else {
      var tmp : Ref := l1.next
      var index : Int := 1

      // package the magic wand required in the loop invariant below
      package list(tmp) --* list(l1)
      { // show how to get from list(tmp) to list(l1):
        fold list(l1) // also requires acc(l1.val) && acc(l1.next)
      }

      while(unfolding list(tmp) in tmp.next != null)
        invariant index >= 0
        invariant list(tmp)// && elems(tmp) == old(elems(l1))[index..]
        invariant list(tmp) --* list(l1) // magic wand instance
      {
        unfold list(tmp)
        var prev : Ref := tmp
        tmp := tmp.next
        index := index + 1

        package list(tmp) --* list(l1) // package new magic wand
        { // we get from list(tmp) to list(l1) by ...
          fold list(prev)
          apply list(prev) --* list(l1)
        }
      }
      unfold list(tmp)
      tmp.next := l2
      fold list(tmp)
      apply list(tmp) --* list(l1) // regain predicate for whole list
    }
  }