field f: Int

function id(n: Int): Int
    ensures result == n

method foo(a: Ref)
    requires acc(a.f, 1/2) && a.f >= 0
    ensures acc(a.f, 1/2)

method simple(x: Ref, y: Ref, p: Perm)
  requires acc(x.f) && acc(y.f)
  ensures  acc(x.f) && acc(y.f)
{
  x.f := y.f + 1
}

method call1(x: Ref)
  requires acc(x.f)
  ensures  acc(x.f)
{
  assume x.f > 0
  foo(x)
  assert x.f >= 0
}

method call2(x: Ref)
  requires acc(x.f)
  ensures  acc(x.f)
{
  assume x.f > 0
  x.f := id(x.f)
  assert x.f >= 0
}

method inhaleExhalePartial(x: Ref)
{
  inhale acc(x.f) && x.f > 0
  foo(x)
  exhale acc(x.f, 1/2)
}

method inhaleExhaleFull(x: Ref)
{
  inhale acc(x.f) && x.f > 0
  foo(x)
  exhale acc(x.f)
}

method permAmount(x: Ref, p: Perm)
{
  assume p > none
  inhale acc(x.f, p) && x.f > 0
  assume p > 1/2
  foo(x)
}

method quantifiedPerm(xs: Seq[Ref])
{
  assume |xs| > 5
  inhale forall x: Ref :: x in xs ==> (acc(x.f) && x.f > 0)

  assert xs[2].f > 0

  var a : Ref := xs[0]
  a.f := 0
}

method bar(x: Ref, y: Ref, p: Perm)
  requires p > none
  requires acc(x.f) && acc(y.f, p)
  ensures  acc(x.f) && acc(y.f, p)
{
  x.f := 5
  assume p > 1/2
  assume y.f == 1
  x.f := y.f + 1
  foo(x)
  assert x.f == y.f + 1
}

method transitivity(a: Ref, n: Int)
    requires n > 0
    requires acc(a.f) && a.f > 0
{
    var res: Int
    res := a.f / n
    assert res >= 0
}