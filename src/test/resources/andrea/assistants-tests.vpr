field f: Int

method loopAssumption()
{
    var x: Int
    assume x <= 100

    while(x <= 10)
        invariant x <= 100
    {
    x := x * 11
    assume x <= 100
    }

    assert x <= 100
}

method alias1(a: Ref, b: Ref, c: Ref)
    requires acc(a.f) && acc(b.f)
{
    var x: Int
    if (c == a) {
        x := c.f
    }
    if(c == b) {
        x := c.f
        assume a == c
        assert x == a.f
        assert false
    }


    assume a == c
    assert x == a.f
}

method alias2(a: Ref, b: Ref, c: Ref)
    requires acc(a.f) && acc(b.f)
    requires a != b
{
    var x: Int
    if (c == a) {
        x := c.f
    } else {
        if(c == b) {
            x := c.f
        }
    }

    assume a == c
    assert x == a.f
}

method test3(a: Int, b: Int, c: Int)
{
var x: Int := 4

assume a == 0
assume b == 1


if (c == a || c == b) {
    x := c
}

assume c == a
assert x == 0
}


method stupidSMT(){
    var a: Int


    if (exists x: Int, y: Int, z: Int :: x > 0 && y > 0 && z > 0 && x*x*x + y*y*y == z*z*z) {
        // complicated condition that is equivalent to false, but canâ€™t be proven by solver
        // effectively unreachable code
        assume a == 0 // assumption 1
    } else {
        assume a == 0 // assumption 2
    }

    assert a == 0
}