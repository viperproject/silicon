field f: Int
field next : Ref
field val : Int

predicate list(start : Ref)
{
  acc(start.val) && acc(start.next) &&
    (start.next != null && list(start.next))
}


method basicPackage(l: Ref)
  requires list(l)
  ensures list(l)
  {
    unfold list(l)
    var tmp : Ref := l.next

    package list(tmp) --* list(l)
    {
      fold list(l)
    }

    apply list(tmp) --* list(l)
}