field f: Int

method loopAssumption()
{
    var x: Int
    assume x <= 100

    while(x <= 10)
        invariant x <= 100
    {
    x := x * 11
    assume x <= 100
    }

    assert x <= 100
}

method alias1(a: Ref, b: Ref, c: Ref)
    requires acc(a.f) && acc(b.f)
{
    var x: Int
    if (c == a) {
        x := c.f + 1
    }
    if(c == b) {
        x := c.f + 1
        assume a == c
        assert x == a.f + 1
        assert false
    }


    assume a == c
    assert x == a.f + 1
}

method alias2(a: Ref, b: Ref, c: Ref)
    requires acc(a.f) && acc(b.f)
    requires a != b
{
    var x: Int
    if (c == a) {
        x := c.f
    } else {
        if(c == b) {
            x := c.f
        }
    }

    assume a == c
    assert x == a.f
}

method test3(a: Int, b: Int, c: Int)
{
var x: Int := 4

assume a == 0
assume b == 1


if (c == a || c == b) {
    x := c + 1
}

assume c == a
assert x == 1
}


method stupidSMT(){
    var a: Int


    if (exists x: Int, y: Int, z: Int :: x > 0 && y > 0 && z > 0 && x*x*x + y*y*y == z*z*z) {
        // complicated condition that is equivalent to false, but canâ€™t be proven by solver
        // effectively unreachable code
        assume a == 0 // assumption 1
    } else {
        assume a == 0 // assumption 2
    }

    assert a == 0
}

method joinerTest(){
    var a: Int
    var n: Int
    assume n >= 0
    var b: Bool


    if (b) {
        a := n + 1
    } else {
        a := 1 + n
    }

    assert a > 0
}

method quantifiedPerm2Seqs3(xs: Seq[Ref], ys: Seq[Ref]) {
  assume |xs| > 5 && |ys| > 3
  inhale forall x: Ref :: x in xs ==> (acc(x.f, wildcard) && x.f > 0)
  inhale forall y: Ref :: y in ys ==> (acc(y.f, wildcard))

  assert xs[0].f > 0 // incorrectly depends on inhale forall x in xs due to heap summary
  // still not precise due to wildcart
}


method quantifiedPerm2Seqs3W(xs: Seq[Ref], ys: Seq[Ref]) {
  assume |xs| > 5 && |ys| > 3
  inhale forall x: Ref :: x in xs ==> (acc(x.f, 1/2) && x.f > 0)
  inhale forall y: Ref :: y in ys ==> (acc(y.f, 1/2))

  assert xs[0].f > 0 // incorrectly depended on inhale forall x in xs due to heap summary
  // is precise now
}