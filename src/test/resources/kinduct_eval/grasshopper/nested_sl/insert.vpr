import "./nested_def.vpr"

method insert(x: Ref) returns (res: Ref)
requires OuterNode(x)
ensures OuterNode(res)
{
    var inn: Ref
    if(x == null){
        inn := new(inext)
        inn.inext := null
        fold InnerNode(inn.inext)
        fold InnerNode(inn)
        res := new(onext, down)
        res.down := inn
        res.onext := null
        fold OuterNode(res.onext)
        fold OuterNode(res)
    } else {
        var nondet: Bool
        var currO: Ref := x
        
        package OuterNode(currO) --* OuterNode(x)
        unfold OuterNode(currO)

        while(nondet && currO.onext != null)
        //invariant acc(currO.onext) && acc(currO.down) && InnerNode(currO.down)
        //invariant OuterNode(currO.onext)
        //invariant OuterNode(currO) --* OuterNode(x)
        {
            nondet := havoc()
            var currO_old: Ref := currO
            currO := currO.onext
            unfold OuterNode(currO)

            package OuterNode(currO) --* OuterNode(x) {
                fold OuterNode(currO_old)
                apply OuterNode(currO_old) --* OuterNode(x)
            }
        }
        
        nondet := havoc()

        // New outer node
        if(nondet){
            var currO_old: Ref := currO
            var newO: Ref := new(*)
            newO.down := null
            fold InnerNode(newO.down)
            newO.onext := currO.onext
            currO.onext := newO
            currO := newO
            package OuterNode(currO) --* OuterNode(x) {
                fold OuterNode(currO_old)
                apply OuterNode(currO_old) --* OuterNode(x)
            }
        } 
        
        // Insert in inner list
        if(currO.down == null){
            var i: Ref := new(*)
            i.inext := null
            fold InnerNode(i)
            currO.down := i
        } else {

            // Go through inner list
            var ic: Ref := currO.down
            var currI: Ref := ic
            package InnerNode(currI) --* InnerNode(ic)
            unfold InnerNode(currI)
            nondet := havoc()

            while(nondet && currI.inext != null)
            //invariant acc(currI.inext)
            //invariant InnerNode(currI.inext)
            //invariant InnerNode(currI) --* InnerNode(ic)
            {
                nondet := havoc()
                
                var currI_old: Ref := currI
                currI := currI.inext
                unfold InnerNode(currI)
                package InnerNode(currI) --* InnerNode(ic){
                    fold InnerNode(currI_old)
                    apply InnerNode(currI_old) --* InnerNode(ic)
                }
            }

            var i: Ref := new(*)
            i.inext := currI.inext
            fold InnerNode(i)
            currI.inext := i
            fold InnerNode(currI)
            apply InnerNode(currI) --* InnerNode(ic)
        }
        
        fold OuterNode(currO)
        apply OuterNode(currO) --* OuterNode(x)
        res := x
        }
}

method havoc() returns (res: Bool)