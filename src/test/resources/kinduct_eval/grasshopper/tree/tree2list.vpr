import "tree.vpr"
import "../sl/sl.vpr"

method insert(x: Ref, newVal: Int) returns (res: Ref)
requires list(x)
ensures list(res)

method freeT(root: Ref)
requires root != null ==> acc(root.left) && acc(root.right) && acc(root.val)
requires root == null ==> tree(root)

method freeL(node: Ref)
requires acc(node.elem) && acc(node.tNext)

method tree2list(root: Ref) returns (res: Ref)
requires tree(root)
ensures list(res)
{
    res := null
    fold list(res)
    
    if(root != null){

        var remaining: Ref := new(elem, tNext)
        remaining.tNext := null
        remaining.elem := root
        fold tList(remaining.tNext)
        fold tList(remaining)

        while(remaining != null)
        //invariant tList(remaining)
        //invariant list(res)
        {
            unfold tList(remaining)
            var current: Ref := remaining.elem
            if(current != null){

                unfold tree(current)

                var lNode: Ref := new(elem, tNext)
                var rNode: Ref := new(elem, tNext)
                lNode.elem := current.left
                rNode.elem := current.right

                rNode.tNext := remaining.tNext
                lNode.tNext := rNode
                remaining.tNext := lNode

                
                res := insert(res, current.val)


                fold tList(rNode)
                fold tList(lNode)
            }
            freeT(current)
            var remaining_prev: Ref := remaining
            remaining := remaining.tNext
            freeL(remaining_prev)
        }
    }    
}