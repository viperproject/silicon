field next : Ref
field val : Int

predicate list(start : Ref)
{
  acc(start.val) && acc(start.next) &&
    (start.next != null && list(start.next))
}


method basicApply()
{
    var x: Int
    var y: Int
    @dependency("Explicit")
    inhale x > 0
    @dependency("Explicit")
    inhale x > 0 --* y > 0
    @dependency("Implicit")
    apply x > 0 --* y > 0
    @testAssertion("Explicit")
    assert y > 0
}


method basicPackage(l: Ref) 
  requires @dependency("Explicit")(list(l))
  ensures list(l)
  {
    @dependency("Implicit")
    unfold list(l)
    var tmp : Ref
    @dependency("Implicit")
    tmp := l.next

    @dependency("Implicit")
    package list(tmp) --* list(l)
    {
      fold list(l) // TODO ake
    }

    @dependency("Implicit")
    apply list(tmp) --* list(l)

    @testAssertion("Explicit")
    assert list(l)
}