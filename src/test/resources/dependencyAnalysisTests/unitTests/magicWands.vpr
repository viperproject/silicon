field next : Ref
field val : Int

predicate list(start : Ref)
{
  acc(start.val) && acc(start.next) &&
    (start.next != null && list(start.next))
}


method basicApply()
{
    var x: Int
    var y: Int
    @dependency("Explicit")
    inhale x > 0
    @dependency("Explicit")
    inhale x > 0 --* y > 0
    @dependency("Implicit")
    apply x > 0 --* y > 0
    @testAssertion("Explicit")
    assert y > 0
}


method basicPackage(l: Ref) 
  requires @dependency("Explicit")(list(l))
  ensures list(l)
  {
    @dependency("Implicit")
    unfold list(l)
    var tmp : Ref
    @dependency("Implicit")
    tmp := l.next

    @dependency("Implicit")
    package list(tmp) --* list(l)
    {
      @dependency()
      fold list(l)
    }

    @dependency("Implicit")
    apply list(tmp) --* list(l)

    @testAssertion("Explicit")
    assert list(l)
}


predicate greater0(a: Int){
    a > 0
}

method advancedPackage(a: Int, b: Int)
  {

    @dependency("Implicit")
    package (greater0(a) && greater0(b)) --* greater0(a + b)
    {
      @dependency("Implicit")
      unfold greater0(a)
      @dependency("Implicit")
      unfold greater0(b)
      @dependency("Implicit")
      fold greater0(a + b)
    }

    @dependency("Explicit")
    inhale greater0(a)
    @dependency("Explicit")
    inhale greater0(b)

    @dependency("Implicit")
    apply (greater0(a) && greater0(b)) --* greater0(a + b)

    @testAssertion("Explicit")
    assert greater0(a + b)
}