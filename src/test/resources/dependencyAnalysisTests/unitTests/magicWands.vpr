field next : Ref
field val : Int
field f: Int

predicate list(start : Ref)
{
  acc(start.val) && acc(start.next) &&
    (start.next != null && list(start.next))
}


method basicApply()
{
    var x: Int
    var y: Int
    @dependency("Explicit")
    inhale x > 0
    @dependency("Explicit")
    inhale x > 0 --* y > 0

    // $PrecisionTest: $READ_ONLY=x,y

    @dependency("Implicit")
    apply x > 0 --* y > 0

    @testAssertion("Explicit")
    assert y > 0
}


method basicPackage(l: Ref) 
  requires @dependency("Explicit")(list(l))
  ensures list(l)
  {
    @dependency("Implicit")
    unfold list(l)
    var tmp : Ref
    @dependency("Implicit")
    tmp := l.next

    @dependency("Implicit")
    package list(tmp) --* list(l)
    {
      @dependency()
      fold list(l)
    }

    // $PrecisionTest: // TODO ake

    @dependency("Implicit")
    apply list(tmp) --* list(l)

    @testAssertion("Explicit")
    assert list(l)
}


predicate greater0(a: Int){
    a > 0
}

method advancedPackage(a: Int, b: Int)
  {

    @dependency("Implicit")
    package (greater0(a) && greater0(b)) --* greater0(a + b)
    {
      @dependency("Implicit")
      unfold greater0(a)
      @dependency("Implicit")
      unfold greater0(b)
      @dependency("Implicit")
      fold greater0(a + b)
    }

    @dependency("Explicit")
    inhale greater0(a)
    @dependency("Explicit")
    inhale greater0(b)

    // $PrecisionTest: $READ_ONLY=a,b

    @dependency("Implicit")
    apply (greater0(a) && greater0(b)) --* greater0(a + b)

    @testAssertion("Explicit")
    assert greater0(a + b)
}

method quantifiedWand(xs: Seq[Int], b: Int)
    requires @dependency("Explicit")(|xs| > 2)
    requires @dependency("Explicit")(forall x: Int :: x in xs ==> (greater0(x) --* greater0(x + b)))
  {
    @dependency("Explicit")
    inhale greater0(xs[0])
    @dependency("Implicit")
    apply  greater0(xs[0]) --* greater0(xs[0] + b)

    // $PrecisionTest: $READ_ONLY=xs[0],b,xs[1] // TODO ake: sequence update

    @testAssertion("Explicit")
    assert greater0(xs[0] + b)
}

method packagePrecision(l: Ref)
  requires @dependency("Explicit")(list(l))
  {
    @dependency("Implicit")
    unfold list(l)
    var tmp : Ref
    @dependency("Implicit")
    tmp := l.next

    // $PrecisionTest: $READ_WRITE=l.val

    @irrelevant("Implicit")
    package list(tmp) --* list(l)
    {
      @irrelevant("Implicit")
      fold list(l)
    }

    @testAssertion("Explicit")
    assert list(tmp)
}

method packageExhale(x: Ref)
  requires @dependency("Explicit")(acc(x.f))
  {

    // $PrecisionTest: $READ_WRITE=x.f

    @dependency("Implicit")
    package acc(x.f, 1/2) --* acc(x.f)


    @testAssertion("Explicit")
    assert perm(x.f) == 1/2
}

method packageExhale2(x: Ref)
  requires @dependency("Explicit")(acc(x.f))
  {

    @dependency("Implicit") // TODO ake: irrelevant
    package acc(x.f, 1/2) --* acc(x.f)

    // $PrecisionTest: $READ_ONLY=x.f

    @dependency("Implicit")
    apply acc(x.f, 1/2) --* acc(x.f)

    @testAssertion("Explicit")
    exhale acc(x.f)
}