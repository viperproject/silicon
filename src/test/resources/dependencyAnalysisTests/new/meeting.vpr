field f: Int

method exhaleInhale(a: Ref)
    requires acc(a.f)
{

    exhale acc(a.f, 1/2)

    inhale acc(a.f, 1/2)

    assert perm(a.f) == write
}

method exhaleImprecision(){
    var x: Ref

    inhale acc(x.f)
    inhale x.f > 0

    exhale acc(x.f, 1/2)

    assert x.f > 0
}

method infeasible1(x: Ref)
    requires acc(x.f, 1/2)
    requires x.f > 0
{
     if(x.f < 0){
        x.f := x.f + 1 // missing node iff infeasible branches are skipped
        assert x.f > 0
     }
}


method infeasible2(x: Ref)
    requires x != null ==> acc(x.f) // unexpected dependency
{
    var a: Int
    if(x == null){ // unexpected dependency
        var a: Int
        a := 0
        assert a >= 0
     }
}


method currentPerm(x: Ref)
    requires acc(x.f, 1/2)
{
    assert perm(x.f) > 1/4
}


method automatedTest()
{
    var a: Int
    a := 0
    a := 1
    a := 0
    assert a == 0
}

field elem: Int
field next: Ref

predicate list(this: Ref) {
  acc(this.elem) && acc(this.next) &&
  (this.next != null ==> list(this.next))
}

method appendListFull(this: Ref, e: Int)
  requires list(this)
  requires 0 <= e && e < 100
  ensures  list(this)
{
  unfold list(this)
  assume 0 <= this.elem && this.elem < 100

  if (this.next == null) {
    var n: Ref

    n := new(elem, next)
    n.elem := e
    n.next := null
    this.next := n
    fold list(n)
  } else {
    appendListFull(this.next, e)
  }

  fold list(this)
}

