field f: Int


method infeasible1(x: Ref)
    requires @dependency()(acc(x.f, 1/2)) // missing dependency iff infeasible branches are skipped
    requires @dependency()(x.f > 0) // missing dependency iff infeasible branches are skipped
{
     if(@dependency()(x.f < 0)){ // missing dependency iff infeasible branches are skipped
        @testAssertion()
        x.f := x.f + 1 // // missing node iff infeasible branches are skipped
     }
}


method infeasible2(x: Ref)
    requires @irrelevant()(x != null ==> acc(x.f)) // unexpected dependency iff infeasible branches are always executed
{
    if(@irrelevant()(x == null)){ // unexpected dependency iff infeasible branches are always executed
        var a: Int
        @dependency()
        a := 0
        @testAssertion()
        assert a >= 0
    }
}

method infeasible3(x: Ref)
{
    if(@irrelevant()(x != null)){ // unexpected dependency iff infeasible branches are always executed
        @irrelevant()
        inhale acc(x.f)
    }

    if(@irrelevant()(x == null)){ // unexpected dependency iff infeasible branches are always executed
        var a: Int
        @dependency()
        a := 0
        @testAssertion()
        assert a >= 0
    }
}

method foo(a: Int, b:Int, x: Ref)
    requires b >= 0
    ensures a >= 0
{
    if(b < 0){
        x.f := a
    }else{
        inhale a > 10
    }

    assert a > 0
}


method currentPerm(x: Ref)
    requires acc(x.f, 1/2)
{
    assert perm(x.f) > 1/4
}

method noAlias(a: Ref, b: Ref, c: Ref)
    requires @dependency()(acc(a.f))
    requires @dependency()(acc(b.f, 1/2))
    requires @irrelevant()(acc(c.f, 1/2))
{
    @testAssertion()
    assert a != b
}


method permTest(a: Ref, b: Ref, n: Int)
    requires @dependency()(acc(a.f))
    requires @irrelevant()(acc(b.f)) && @irrelevant()(b.f > 0)
{
    @dependency()
    assume n > 0
    @irrelevant()
    a.f := b.f + 2
    @dependency()
    a.f := n
    @testAssertion()
    assert a.f >= 0
}
