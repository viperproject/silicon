field f: Int

method stateConsolidation(x: Ref, y: Ref, z: Ref)
  requires @dependency("Precondition")(acc(x.f, 1/2))
  requires @dependency("Precondition")(acc(y.f, 1/2))
  requires @irrelevant("Precondition")(acc(z.f, 1/2))
{
  var a: Ref
  @dependency("Explicit")
  inhale acc(a.f, 1/2)

  @dependency("Explicit")
  assume a == x

  @testAssertion("Explicit")
  assert a != y  // triggers state consolidation
}

method stateConsolidation2(x: Ref, y: Ref, z: Ref)
  requires @dependency("Precondition")(acc(x.f, 1/2))
  requires @dependency("Precondition")(acc(y.f, 1/2))
  requires @irrelevant("Precondition")(acc(z.f, 1/2))
{
  var a: Ref
  @dependency("Explicit")
  inhale acc(a.f, 1/2)

  @dependency("Explicit")
  assume a == x  // chunks are merged somewhere

  @testAssertion("Explicit")
  assert perm(x.f) == write
}


method stateConsolidation3(x: Ref, y: Ref, z: Ref)
  requires @dependency("Precondition")(acc(x.f, 1/2))
  requires @dependency("Precondition")(acc(y.f, 1/2))
  requires @irrelevant("Precondition")(acc(z.f, 1/2))
{
  var a: Ref
  @dependency("Explicit")
  inhale acc(x.f, 1/2)

  @testAssertion("Explicit")
  assert perm(x.f) == write
}


method noAlias(a: Ref, b: Ref, c: Ref)
    requires @dependency("Precondition")(acc(a.f))
    requires @dependency("Precondition")(acc(b.f, 1/2))
    requires @irrelevant("Precondition")(acc(c.f, 1/2))
{

    @testAssertion("Explicit")
    assert a != b
}

