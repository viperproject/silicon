field f: Int
field g: Int

// When executing the branch, the 1st inhale is reported as a dependency, the 2nd inhale is ignored.
// If the branch is not executed, the 2nd inhale is reported as a dependency
// In reality, the 2nd inhale is all we need for the assertion.
method nonUniqueUnsatCore(x: Ref)
    requires @irrelevant("Explicit")(x != null ==> acc(x.f))
{
    var a: Int
    if(@irrelevant("PathCondition")(x == null)){
        @irrelevant("Explicit") // imprecise
        inhale a >= 0
    }

    @dependency("Explicit")
    inhale a >= 0

    @testAssertion("Explicit")
    assert a >= 0
}

method unprovableInfeasibility(){
    var a: Int

    if (exists x: Int, y: Int, z: Int :: x > 0 && y > 0 && z > 0 && x*x*x + y*y*y == z*z*z) {
        // complicated condition that is equivalent to false, but canâ€™t be proven by solver
        // effectively unreachable code
        @irrelevant("Explicit")
        assume a == 0 // assumption 1
    } else {
        @dependency("Explicit")
        assume a == 0 // assumption 2
    }

    @testAssertion("Explicit")
    assert a == 0
}

// Implication causes branching.
// If x == null is assumed, only the assignment is reported as a dependency
// If x != null, the branch is infeasible, but we executed it anyways. The implication and branch condition are reported as dependencies.
method infeasible2(x: Ref)
    requires @irrelevant("Explicit")(x != null ==> acc(x.f)) // unexpected dependency
{
    if(@irrelevant("PathCondition")(x == null)){ // unexpected dependency
        var a: Int

        @dependency("Implicit")
        a := 0

        @testAssertion("Explicit")
        assert a >= 0
     }
}

method exhaleImprecision(){
    var x: Ref

    @dependency("Explicit")
    inhale acc(x.f)

    @dependency("Explicit")
    inhale x.f > 0

    @dependency("Implicit")
    x.f := x.f + 1

    @irrelevant("Implicit") // unexpected dependency
    exhale acc(x.f, 1/2)

    @testAssertion("Explicit")
    assert x.f > 1
}

// this is precise as opposed to later examples with wildcards
method quantifiedPerm2(xs: Seq[Ref], ys: Seq[Ref])
  requires @dependency("Explicit")(|xs| > 5)
  requires @irrelevant("Explicit")(|ys| > 3)
{
  @dependency("Explicit")
  inhale (forall x: Ref :: x in xs ==> (acc(x.f, wildcard) && x.f > 0))
  @irrelevant("Explicit") // this is precise (as opposed to quantifiedPerm3
  inhale forall y: Ref :: y in ys ==> (acc(y.f, wildcard))

  @testAssertion("Explicit")
  assert xs[0].f > 0
}

// issue #01 - imprecision due to wildcards
// when accessing a qp resource, we check Z < (x in xs? k1:Z) + (y in ys? k2:Z) the unsat core contains dependencies to all qp perm amounts (e.g. wildcard)
method quantifiedPerm3(xs: Seq[Ref], ys: Seq[Ref])
  requires @dependency("Explicit")(|xs| > 5)
  requires @irrelevant("Explicit")(|ys| > 3)
{
  @dependency("Explicit")
  inhale (forall x: Ref :: x in xs ==> (acc(x.f, wildcard) && x.f > 0))
  @irrelevant("Explicit") // unexpected dependency (wildcards)
  inhale forall y: Ref :: y in ys ==> (acc(y.f, wildcard) && y.f > 0)

  @testAssertion("Explicit")
  assert xs[0].f > 0
}

// issue #01 - imprecision due to perm amounts
// when accessing a qp resource, we check Z < (x in xs? k1:Z) + (y in ys? k2:Z) the unsat core contains dependencies to all qp perm amounts
method quantifiedPerm4(xs: Seq[Ref], ys: Seq[Ref])
  requires @dependency("Explicit")(|xs| > 5)
  requires @irrelevant("Explicit")(|ys| > 3)
{
  var p1: Perm
  @dependency("Explicit")
  assume none < p1 && p1 < 1/2

  var p2: Perm
  @irrelevant("Explicit")
  assume none < p2 && p2 < 1/2 // unexpected dependency

  @dependency("Explicit")
  inhale (forall x: Ref :: x in xs ==> (acc(x.f, p1) && x.f > 0))

  @irrelevant("Explicit") // unexpected dependency
  inhale forall y: Ref :: y in ys ==> (acc(y.f, p2) && y.f > 0)

  @testAssertion("Explicit")
  assert xs[0].f > 0
}

// havocs all resources of the given fields conditionally on whether it can prove
// non-aliasing or not (e.g. x.f --> x == y? new snap : old snap)
method quasihavoc1(x: Ref, y: Ref)
    requires @dependency("Explicit")(acc(x.f))
    requires @dependency("Explicit")(x.f == 3)
    requires @dependency("Explicit")(x != y)
{
    @irrelevant() // unexpected dependency
    quasihavoc y.f   // does nothing. we have no permission
    @testAssertion("Explicit")
    assert x.f == 3
}

// imprecision due to non-uniqueness of unsat core
// in this example the loop condition and invariant res >= 0 would be enough
// to prove the invariant res >= 0. However, the SMT solver chooses to prove it
// via the invariant i>=0
// interestingly, proving "res >= 0 is preserved by the loop body" has the following unsat core
// old(res) >= 0, res = old(res) + old(i), i = old(i) - 1, i >= 0
// the last one comes from the asserting that invariant i >= 0 is preserved!
// the last two terms could be replaced by old(i) > 0 (the loop condition)
method loop1(){
    var i: Int
    var res: Int
    @dependency("Implicit")
    res := 0

    @irrelevant("Implicit")
    i := 10
    while(@dependency("PathCondition")(i > 0))
        invariant @irrelevant("LoopInvariant")(i <= 10)
        invariant @irrelevant("LoopInvariant")(i >= 0)
        invariant @dependency("LoopInvariant")(res >= 0)
    {
        @dependency("Implicit")
        res := res + i
        @irrelevant("Implicit")
        i := i - 1
    }
    @testAssertion("Explicit")
    assert res >= 0
}

method inhaleImprecision(){
    var x: Ref

    @dependency("Explicit")
    inhale acc(x.f, 1/2)
    @dependency("Explicit")
    inhale x.f > 0

    @irrelevant("Implicit")
    inhale acc(x.f, 1/2)

    @testAssertion("Explicit")
    assert x.f > 0
}

method packageExhale2(x: Ref)
  requires @dependency("Explicit")(acc(x.f))
  {

    @irrelevant("Rewrite")
    package acc(x.f, 1/2) --* acc(x.f)

    @irrelevant("Rewrite")
    apply acc(x.f, 1/2) --* acc(x.f)

    @testAssertion("Explicit")
    exhale acc(x.f)
}