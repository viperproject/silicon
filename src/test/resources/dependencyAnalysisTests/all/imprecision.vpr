field f: Int
field g: Int

// When executing the branch, the 1st inhale is reported as a dependency, the 2nd inhale is ignored.
// If the branch is not executed, the 2nd inhale is reported as a dependency
// In reality, the 2nd inhale is all we need for the assertion.
method nonUniqueUnsatCore(x: Ref)
    requires @irrelevant("Precondition")(x != null ==> acc(x.f))
{
    var a: Int
    if(@irrelevant("PathCondition")(x == null)){
        @irrelevant("Explicit") // imprecise
        inhale a >= 0
    }

    @dependency("Explicit")
    inhale a >= 0

    @testAssertion("Explicit")
    assert a >= 0
}

method unprovableInfeasibility(){
    var a: Int

    if (exists x: Int, y: Int, z: Int :: x > 0 && y > 0 && z > 0 && x*x*x + y*y*y == z*z*z) {
        // complicated condition that is equivalent to false, but canâ€™t be proven by solver
        // effectively unreachable code
        @irrelevant("Explicit")
        assume a == 0 // assumption 1
    } else {
        @dependency("Explicit")
        assume a == 0 // assumption 2
    }

    @testAssertion("Explicit")
    assert a == 0
}

// Implication causes branching.
// If x == null is assumed, only the assignment is reported as a dependency
// If x != null, the branch is infeasible, but we executed it anyways. The implication and branch condition are reported as dependencies.
method infeasible2(x: Ref)
    requires @irrelevant("Precondition")(x != null ==> acc(x.f)) // unexpected dependency
{
    if(@irrelevant("PathCondition")(x == null)){ // unexpected dependency
        var a: Int

        @dependency("SourceCode")
        a := 0

        @testAssertion("Explicit")
        assert a >= 0
     }
}

method exhaleImprecision(){
    var x: Ref

    @dependency("Explicit")
    inhale acc(x.f)

    @dependency("Explicit")
    inhale x.f > 0

    @dependency("SourceCode")
    x.f := x.f + 1

    @irrelevant("Implicit") // unexpected dependency
    exhale acc(x.f, 1/2)

    @testAssertion("Explicit")
    assert x.f > 1
}

// this is precise as opposed to later examples with wildcards
method quantifiedPerm2(xs: Seq[Ref], ys: Seq[Ref])
  requires @dependency("Precondition")(|xs| > 5)
  requires @irrelevant("Precondition")(|ys| > 3)
{
  @dependency("Explicit")
  inhale (forall x: Ref :: x in xs ==> (acc(x.f, wildcard) && x.f > 0))
  @irrelevant("Explicit") // this is precise (as opposed to quantifiedPerm3
  inhale forall y: Ref :: y in ys ==> (acc(y.f, wildcard))

  @testAssertion("Explicit")
  assert xs[0].f > 0
}

// issue #01 - imprecision due to wildcards
// when accessing a qp resource, we check Z < (x in xs? k1:Z) + (y in ys? k2:Z) the unsat core contains dependencies to all qp perm amounts (e.g. wildcard)
method quantifiedPerm3(xs: Seq[Ref], ys: Seq[Ref])
  requires @dependency("Precondition")(|xs| > 5)
  requires @irrelevant("Precondition")(|ys| > 3)
{
  @dependency("Explicit")
  inhale (forall x: Ref :: x in xs ==> (acc(x.f, wildcard) && x.f > 0))
  @irrelevant("Explicit") // unexpected dependency (wildcards)
  inhale forall y: Ref :: y in ys ==> (acc(y.f, wildcard) && y.f > 0)

  @testAssertion("Explicit")
  assert xs[0].f > 0
}

// issue #01 - imprecision due to perm amounts
// when accessing a qp resource, we check Z < (x in xs? k1:Z) + (y in ys? k2:Z) the unsat core contains dependencies to all qp perm amounts
method quantifiedPerm4(xs: Seq[Ref], ys: Seq[Ref])
  requires @dependency("Precondition")(|xs| > 5)
  requires @irrelevant("Precondition")(|ys| > 3)
{
  var p1: Perm
  @dependency("Explicit")
  assume none < p1 && p1 < 1/2

  var p2: Perm
  @irrelevant("Explicit")
  assume none < p2 && p2 < 1/2 // unexpected dependency

  @dependency("Explicit")
  inhale (forall x: Ref :: x in xs ==> (acc(x.f, p1) && x.f > 0))

  @irrelevant("Explicit") // unexpected dependency
  inhale forall y: Ref :: y in ys ==> (acc(y.f, p2) && y.f > 0)

  @testAssertion("Explicit")
  assert xs[0].f > 0
}

// havocs all resources of the given fields conditionally on whether it can prove
// non-aliasing or not (e.g. x.f --> x == y? new snap : old snap)
method quasihavoc1(x: Ref, y: Ref)
    requires @dependency("Precondition")(acc(x.f))
    requires @dependency("Precondition")(x.f == 3)
    requires @dependency("Precondition")(x != y)
{
    @irrelevant() // unexpected dependency
    quasihavoc y.f   // does nothing. we have no permission
    @testAssertion("Explicit")
    assert x.f == 3
}


method inhaleImprecision(){
    var x: Ref

    @dependency("Explicit")
    inhale acc(x.f, 1/2)
    @dependency("Explicit")
    inhale x.f > 0

    @irrelevant("Explicit")
    inhale acc(x.f, 1/2)

    @testAssertion("Explicit")
    assert x.f > 0
}

method packageExhale2(x: Ref)
  requires @dependency("Precondition")(acc(x.f))
  {

    @irrelevant("Rewrite")
    package acc(x.f, 1/2) --* acc(x.f)

    @irrelevant("Rewrite")
    apply acc(x.f, 1/2) --* acc(x.f)

    @testAssertion("Explicit")
    exhale acc(x.f)
}

method quantifiedFieldAssign(){
    var a: Int
    var idx: Int
    var xs: Seq[Ref]

    @irrelevant("Explicit")
    inhale |xs| > 2  // imprecise
    @irrelevant("SourceCode")
    idx := 0  // imprecise
    inhale forall xi: Ref :: xi in xs ==> acc(xi.f)
    @irrelevant("SourceCode")
    xs[idx].f := a  // internal dependency

    @testAssertion("Explicit")
    exhale acc(xs[0].f)
}
