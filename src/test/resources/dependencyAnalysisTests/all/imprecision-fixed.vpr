field f: Int

method permTest(a: Ref, b: Ref, n: Int)
    requires @dependency("Precondition")(acc(a.f))
    requires @irrelevant("Precondition")(acc(b.f)) && @irrelevant("Precondition")(b.f > 0)
{
    @dependency("Explicit")
    assume n > 0
    @irrelevant("Implicit") // fixed imprecision (field assign)
    a.f := b.f + 2
    @dependency("Implicit")
    a.f := n
    @testAssertion("Explicit")
    assert a.f >= 0
}


method quantifiedPerm4(xs: Seq[Ref], ys: Seq[Ref])
  requires @dependency("Precondition")(|xs| > 5)
  requires @irrelevant("Precondition")(|ys| > 3)
{
  @dependency("Explicit")
  inhale (forall x: Ref :: x in xs ==> acc(x.f) && x.f > 0)
  @irrelevant("Explicit") // fixed imprecision (heap summary)
  inhale forall y: Ref :: y in ys ==> acc(y.f)

  @testAssertion("Explicit")
  assert xs[0].f > 0
}

// issue #02 - imprecision due to field assign with qp
// issue: access to a quantified field depended on all writes to any location covered by this qp resource
// expl:  when exhaling permission to a single location of a qp resource (e.g. for field assign),
//        permissions for other locations are inhaled. The inhale of full permission after the field assign
//        depends on this inhale.
// solution:
// - inhale of remaining permissions / full permission after assignments are labelled internal
// - exhale is implicit
// - lhs and rhs are split such that transitive edges only go from lhs to rhs
method quantifiedPerm5(xs: Seq[Ref], ys: Seq[Ref])
  requires @dependency("Precondition")(|xs| > 5)
  requires @irrelevant("Precondition")(|ys| > 3)
{
  @dependency("Explicit")
  inhale forall x: Ref :: x in xs ==> acc(x.f)
  @irrelevant("Explicit")
  inhale forall y: Ref :: y in ys ==> acc(y.f)

  @irrelevant("Implicit") // fixed imprecision (field assign with qp)
  xs[0].f := ys[0].f + 2
  @testAssertion("Implicit")
  xs[0].f := 2
}

// issue #03
// Imprecision due to state consolidation triggered by assertion
// state consolidation infers pair-wise non-aliasing of all 3 resources in one assumption.
// This assumption depends on all preconditions.
// The assertion depends on this assumption.
// solution: wrap with analysis labels (see viper.silicon.resources.NonQuantifiedPropertyInterpreter.buildForEach)
// and disable transitive edges (see viper.silicon.rules.DefaultStateConsolidator.consolidate)
method noAlias(a: Ref, b: Ref, c: Ref)
    requires @dependency("Precondition")(acc(a.f))
    requires @dependency("Precondition")(acc(b.f, 1/2))
    requires @irrelevant("Precondition")(acc(c.f, 1/2)) // fixed imprecision (state consolidation)
{
    @testAssertion("Explicit")
    assert a != b
}

method fieldAccessPrecision(){
    var x: Ref
    var y: Ref

    @dependency("Explicit")
    inhale acc(x.f)
    @dependency("Explicit")
    inhale x.f > 0

    @irrelevant("Explicit")
    inhale acc(y.f)
    @irrelevant("Implicit")
    y.f := y.f + 1

    @testAssertion("Explicit")
    assert x.f >= 0
}

method fieldAccessPrecision2(){
    var x: Ref
    var y: Ref

    @dependency("Explicit")
    inhale acc(x.f)
    @irrelevant("Explicit")
    inhale x.f > 0

    @irrelevant("Explicit")
    inhale acc(y.f)
    @irrelevant("Implicit")
    x.f := y.f + 1

    @testAssertion("Explicit")
    exhale acc(x.f)
}