field gen_f: Int

predicate gen_confuse(i: Int){
  i >= 0
}

predicate gen_confuse_with_impl(i: Int, x: Ref){
  i >= 0 ==> acc(x.f)
}

function gen_add(a: Int, b: Int): Int
  ensures result == a + b

function gen_add_positive(a: Int, b: Int): Int
  requires a >= 0 && b >= 0
  ensures result == a + b
  ensures result >= 0

method incr(a: Ref)
  requires acc(a.f)
  ensures acc(a.f)
  ensures a.f == old(a.f) + 1
{
  a.f := a.f + 1
}

method gen_incr_pure(a: Int) returns (res: Int)
  ensures res == a + 1
{
  res := a + 1
}

SNIPPET baseline$=${}

SNIPPET assignment_pure$=${
  @irrelevant("Implicit")
  $RW_INT_PURE_0 := $RO_INT_0 + $RO_INT_1
}

SNIPPET assignment_field$=${
  @irrelevant("Implicit")
  $RW_INT_FIELD_0 := $RO_INT_0 + $RO_INT_1
}

SNIPPET branch_div0$=${
  if(@irrelevant("PathCondition")($RO_INT_0 > 0)){
    @irrelevant("Implicit")
    $RW_INT_0 := $RO_INT_1 / $RO_INT_0
  }else{
    @irrelevant("Implicit")
    $RW_INT_0 := $RO_INT_1 * $RO_INT_0
  }
}

SNIPPET inhale_invariant$=${
  var gen_i: Int
  @irrelevant("Explicit")
  inhale $INVARIANT && gen_i > 0
}

SNIPPET assert$=${
  var gen_i: Int
  @irrelevant("Explicit")
  inhale gen_i > 0
  @irrelevant()
  assert $INVARIANT && gen_i > 0
}


// fold-unfold with implication
SNIPPET fold_unfold_with_implication$=${
  var gen_x: Ref
  @irrelevant("Explicit")
  inhale acc(gen_x.f)
  @irrelevant("Implicit")
  fold gen_confuse_with_impl($RO_INT_0, gen_x)
  @irrelevant("Implicit")
  unfold gen_confuse_with_impl($RO_INT_0, gen_x)
}

// function call
SNIPPET function_add$=${
  @irrelevant("Implicit")
  $RW_INT_0 := gen_add($RO_INT_0, $RO_INT_1)
  @irrelevant("Implicit")
  $RW_INT_1 := gen_add($RW_INT_0, $RO_INT_2)
}


SNIPPET method_call_impure$=${
  var gen_ref_0: Ref
  @irrelevant("Implicit")
  gen_ref_0 := new(f)
  @irrelevant("Implicit")
  incr(gen_ref_0)
}

SNIPPET method_call_pure$=${
  @irrelevant("Implicit")
  $RW_INT_0 := gen_incr_pure($RO_INT_0)
}

SNIPPET branch$=${
  var gen_i: Int
  if(@irrelevant("PathCondition")($RO_INT_0 > gen_i)){
    @irrelevant("Implicit")
    $RW_INT_0 := 10
  }else{
    @irrelevant("Implicit")
    $RW_INT_0 := $RO_INT_0 + $RO_INT_1
  }
}

SNIPPET nested_branch$=${
  var gen_c: Int
  if(@irrelevant("PathCondition")($RO_INT_0 > gen_c && $RO_INT_1 > gen_c)){
    var gen_i: Int
    @irrelevant("Implicit")
    gen_i := $RO_INT_0 + $RO_INT_1
    @irrelevant("Implicit")
    $RW_INT_0 := 10
  }else{
    if(@irrelevant("PathCondition")($RO_INT_0 > gen_c + 5)){
      @irrelevant("Implicit")
      $RW_INT_0 := 30
    }else{
      var gen_i: Int
      @irrelevant("Implicit")
      gen_i := $RO_INT_0 + $RO_INT_1
    }
  }
}

SNIPPET infeasible_branch$=${
  if(@irrelevant("PathCondition")($INVARIANT)){
    @irrelevant("Implicit")
    $RW_INT_0 := 10
  }else{
    // unreachable
    @irrelevant("Implicit")
    $RO_INT_FIELD_0 := $RO_INT_1 - $RO_INT_0
    
    @irrelevant()
    assert false
  }
}

// branches & function calls
SNIPPET branch_function$=${
  var gen_c: Int
  @irrelevant("Explicit")
  inhale gen_c > 0
  if(@irrelevant("PathCondition")($RO_INT_0 > gen_c && $RO_INT_1 > gen_c)){
    @irrelevant("Implicit")
    $RW_INT_0 := gen_add_positive($RO_INT_0, $RO_INT_1)
  }else{
    if(@irrelevant("PathCondition")($RO_INT_0 > gen_c)){
      @irrelevant("Implicit")
      $RW_INT_0 := gen_add_positive($RO_INT_0, gen_c)
    }else{
      @irrelevant("Implicit")
      $RW_INT_0 := 0
    }
  }
  
  @irrelevant()
  assert $RW_INT_0 >= 0
}


SNIPPET disjoint_ref$=${
  var gen_x: Ref
  @irrelevant("Explicit")
  inhale acc(gen_x.f)

  @irrelevant("Implicit")
  gen_x.f := $RO_INT_0 + $RO_INT_1

  @irrelevant("Implicit")
  $RW_INT_0 := gen_x.f
}

SNIPPET disjoint_ref_disjoint_field$=${
  var gen_x: Ref
  @irrelevant("Explicit")
  inhale acc(gen_x.gen_f)

  @irrelevant("Implicit")
  gen_x.gen_f := $RO_INT_0 + $RO_INT_1

  @irrelevant("Implicit")
  $RW_INT_0 := gen_x.gen_f
}


SNIPPET disjoint_ref_quantified$=${
  var gen_xs: Seq[Ref]
  @irrelevant("Explicit")
  inhale |gen_xs| > 2
  @irrelevant("Explicit")
  inhale forall gen_x: Ref :: gen_x in gen_xs ==> acc(gen_x.f)
  @irrelevant("Explicit")
  inhale forall gen_x: Ref :: gen_x in gen_xs ==> gen_x.f < 0

  @irrelevant("Implicit")
  gen_xs[0].f := gen_xs[1].f + $RO_INT_0 - $RO_INT_1

  @irrelevant("Implicit")
  $RW_INT_0 := gen_xs[0].f + gen_xs[1].f
}


SNIPPET disjoint_ref_disjoint_field_quantified$=${
  var gen_xs: Seq[Ref]
  @irrelevant("Explicit")
  inhale |gen_xs| > 2
  @irrelevant("Explicit")
  inhale forall gen_x: Ref :: gen_x in gen_xs ==> acc(gen_x.gen_f)
  @irrelevant("Explicit")
  inhale forall gen_x: Ref :: gen_x in gen_xs ==> gen_x.gen_f < 0

  @irrelevant("Implicit")
  gen_xs[0].gen_f := gen_xs[1].gen_f + $RO_INT_0 - $RO_INT_1

  @irrelevant("Implicit")
  $RW_INT_0 := gen_xs[0].gen_f + gen_xs[1].gen_f 
}

SNIPPET while_pure$=${
  var gen_start: Int, gen_c: Int
  @irrelevant("Explicit")
  inhale gen_c >= 0
  @irrelevant("Implicit")
  gen_start := $RW_INT_PURE_0
  @irrelevant("Implicit")
  $RW_INT_PURE_1 := 0
  while(@irrelevant("PathCondition")($RW_INT_PURE_0 > gen_c))
    invariant $ACC_INVARIANT
    invariant @irrelevant("LoopInvariant")($GEN_ACC_INVARIANT)
    invariant @irrelevant("LoopInvariant")($RW_INT_PURE_0 <= gen_start)
    invariant @irrelevant("LoopInvariant")($RW_INT_PURE_1 == (gen_start-$RW_INT_PURE_0)*$RO_INT_PURE_0)
  {
    @irrelevant("Implicit")
    $RW_INT_PURE_1 := $RW_INT_PURE_1 + $RO_INT_PURE_0
    @irrelevant("Implicit")
    $RW_INT_PURE_0 := $RW_INT_PURE_0 - 1
  }
}

SNIPPET while_perm$=${
  var gen_start: Int, gen_c: Int
  @irrelevant("Explicit")
  inhale gen_c >= 0
  @irrelevant("Implicit")
  gen_start := $RW_INT_FIELD_0
  @irrelevant("Implicit")
  $RW_INT_FIELD_1 := 0
  while(@irrelevant("PathCondition")($RW_INT_FIELD_0 > gen_c))
    invariant $ACC_INVARIANT
    invariant @irrelevant("LoopInvariant")($GEN_ACC_INVARIANT)
    invariant @irrelevant("LoopInvariant")($RW_INT_FIELD_0 <= gen_start)
    invariant @irrelevant("LoopInvariant")($RW_INT_FIELD_1 == (gen_start-$RW_INT_FIELD_0)*10)
  {
    @irrelevant("Implicit")
    $RW_INT_FIELD_1 := $RW_INT_FIELD_1 + 10
    @irrelevant("Implicit")
    $RW_INT_FIELD_0 := $RW_INT_FIELD_0 - 1
  }
}

SNIPPET magic_wand$=${
    var gen_i: Int
    var gen_x: Ref
    @irrelevant("Explicit")
    inhale gen_i > 0
    @irrelevant("Explicit")
    inhale acc(gen_x.f) && gen_x.f > 0
    @irrelevant("Implicit")
    package gen_i >= 0 --* acc(gen_x.f) && gen_x.f > 0
    @irrelevant("Implicit")
    apply gen_i >= 0 --* acc(gen_x.f) && gen_x.f > 0
}


SNIPPET quasihavoc$=${
  @irrelevant("Implicit")
  quasihavoc $RW_INT_FIELD_0
}

SNIPPET quasihavoc_disjoint_ref$=${
  var gen_x: Ref
  @irrelevant("Implicit")
  gen_x := new(f)
  @irrelevant("Implicit")
  quasihavoc gen_x.f
}

SNIPPET quasihavoc_disjoint_ref_disjoint_field$=${
  var gen_x: Ref
  @irrelevant("Implicit")
  gen_x := new(gen_f)
  @irrelevant("Implicit")
  quasihavoc gen_x.gen_f
}


SNIPPET goto_pure$=${
  @irrelevant("Implicit")
  $RW_INT_PURE_0 := 0
  var gen_n: Int
  @irrelevant("Implicit")
  gen_n := 0
  label head
    invariant @irrelevant("LoopInvariant")(gen_n >= 0)
    invariant @irrelevant("LoopInvariant")($RW_INT_PURE_0 == gen_n * $RO_INT_PURE_0)

  @irrelevant("Implicit")
  $RW_INT_PURE_0 := $RW_INT_PURE_0 + $RO_INT_PURE_0
  @irrelevant("Implicit")
  gen_n := gen_n + 1

  if(@irrelevant("PathCondition")($RW_INT_PURE_0 != 5 * $RO_INT_PURE_0)){
    goto head
  }

  @irrelevant()
  assert $RW_INT_PURE_0 == gen_n * $RO_INT_PURE_0
}
