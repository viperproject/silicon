var f:Int

method m(a:Ref)
requires acc(a.f, wildcard)
ensures acc(a.f,wildcard)
//ensures a.f == old(a.f)
{
    m(a)
    assert(a.f == old(a.f))
}

method m2(a:Ref)
requires acc(a.f,write)
ensures acc(a.f,write)
//ensures a.f == old(a.f)
{
    m2(a)
    //:: ExpectedOutput(assert.failed:assertion.false)
    assert(a.f == old(a.f))
}

method m3(a:Seq[Ref])
requires forall i:Int :: i in [0..|a|) ==> acc(a[i].f, wildcard)
ensures forall j:Int :: j in [0..|a|) ==> acc(a[j].f, wildcard)
// TODO: incompleteness - we have to ensure it's "oldity"  // Yannis: works for me...
//ensures forall l:Int :: l in [0..|a|) ==> a[l].f == old(a[l].f)
{
    m3(a)
    assert(forall k:Int :: k in [0..|a|) ==> a[k].f == old(a[k].f))
}