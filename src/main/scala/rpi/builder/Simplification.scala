package rpi.builder

import rpi.util.ast.Expressions._
import rpi.util.ast.Statements._
import viper.silver.ast

trait Simplification extends ProgramBuilder {
  /**
    * Simplifies the all statements generated by the given method.
    *
    * @param generate The generator method.
    */
  protected def simplified(generate: => Unit): Unit =
    scoped(generate).foreach { statement =>
      val simplified = simplifyStatement(statement, Seq.empty, Seq.empty)
      addStatement(simplified)
    }

  /**
    * Simplifies the given statement using the given facts.
    *
    * @param statement The statement to simplify.
    * @param positive  The positive facts.
    * @param negative  The negative facts (negation of positive facts).
    * @return The simplified statement.
    */
  private def simplifyStatement(statement: ast.Stmt, positive: Seq[ast.Exp], negative: Seq[ast.Exp]): ast.Stmt =
    statement match {
      case ast.Seqn(statements, declarations) =>
        val simplified = statements.map { statement => simplifyStatement(statement, positive, negative) }
        makeSequence(simplified, declarations)
      case ast.If(condition, thenBranch, elseBranch) =>
        val (simplified, collectedPositive, collectedNegative) = simplifyExpression(simplify(condition), positive, negative)
        simplified match {
          case ast.TrueLit() =>
            simplifyStatement(thenBranch, positive ++ collectedPositive, negative ++ collectedNegative)
          case ast.FalseLit() =>
            simplifyStatement(elseBranch, positive ++ collectedNegative, negative ++ collectedPositive)
          case _ =>
            val simplifiedThen = simplifyStatement(thenBranch, positive ++ collectedPositive, negative ++ collectedNegative)
            val simplifiedElse = simplifyStatement(elseBranch, positive ++ collectedNegative, negative ++ collectedPositive)
            makeConditional(simplified, simplifiedThen, simplifiedElse)
        }
      case _ =>
        statement
    }

  /**
    * Simplifies the given expression using the given fact.
    *
    * @param expression The expression to simplify.
    * @param positive   The positive facts.
    * @param negative   The negative facts.
    * @return The simplified expression and the collected facts.
    */
  private def simplifyExpression(expression: ast.Exp, positive: Seq[ast.Exp], negative: Seq[ast.Exp]): (ast.Exp, Seq[ast.Exp], Seq[ast.Exp]) =
    expression match {
      case ast.EqCmp(left, right) =>
        val simplified = simplifyAtom(expression, positive, negative)
        val collectedPositive = Seq(makeEquality(left, right), makeEquality(right, left))
        val collectedNegative = Seq(makeInequality(left, right), makeInequality(right, left))
        (simplified, collectedPositive, collectedNegative)
      case ast.NeCmp(left, right) =>
        val simplified = simplifyAtom(expression, positive, negative)
        val collectedPositive = Seq(makeInequality(left, right), makeInequality(right, left))
        val collectedNegative = Seq(makeEquality(left, right), makeEquality(right, left))
        (simplified, collectedPositive, collectedNegative)
      case and: ast.And =>
        val (left, positiveLeft, negativeLeft) = simplifyExpression(and.left, positive, negative)
        val (right, positiveRight, negativeRight) = simplifyExpression(and.right, positive ++ positiveLeft, negative ++ negativeLeft)
        val simplified = simplifyAnd(makeAnd(left, right))
        (simplified, positiveLeft ++ positiveRight, negativeLeft ++ negativeRight)
      case _ =>
        (expression, positive, negative)
    }

  /**
    * Simplifies the given atomic expression.
    *
    * @param expression The atom expression to simplify.
    * @param positive   The positive facts.
    * @param negative   The negative facts.
    * @return The simplified atomic expression.
    */
  private def simplifyAtom(expression: ast.Exp, positive: Seq[ast.Exp], negative: Seq[ast.Exp]): ast.Exp =
    if (positive.contains(expression)) makeTrue
    else if (negative.contains(expression)) makeFalse
    else expression
}